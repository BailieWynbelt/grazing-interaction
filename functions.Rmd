---
title: "Functions"
author: "Andrew Antaya"
date: "June 24, 2019"
output: html_notebook
---
***
#### Designed to be read into the R environment first and then called when needed by a different script.
***
### The "se" (Standard Error) Function

**Input:** The values of a single variable in numerical vector format.

**What it Does:** Calculates the standard error (se) commongly used in statistics.

**Output:** A single numerical value.
```{r}
se <- function(x){sqrt(var(x)/length(x))}
```
***
### The "cleandates" Funcion

**Input:** A standardized camera trap dataframe generated by our custom Excel macro (HorseImaging.xlsm).

**What it Does:** It takes the "ImageDate" and "ImageTime" columns, combines them together into a new column "DateTime", then removes the "ImageDate" and "ImageTime" columns. It then converts the "DateTime" column into a S3 class POSIXlt (calendar date and time) It then arranges the dataframe from lowest time to greatest time. 

**Output:** A 'cleaned' dataframe that has the correct date and time format, with all rows arranged in chronological order. (Note: you have assign the output of the function to the original dataframe if you want to overwrite the original dataframe).
```{r}
cleandates <- function(cameradf){
  cameradf <- unite(cameradf, ImageDate, ImageTime, col = "DateTime", sep = " ", remove = TRUE)
  cameradf$DateTime <- mdy_hms(cameradf$DateTime)
  cameradf <- arrange(cameradf, DateTime)
  return(cameradf)
}
```
***
### The "speciestotal" Function

**Input:** A standard camera trap dataframe (i.e. camerdf), and the name of the species in quotations (e.g. "Horse")

**What it Does:** This function adds up the number of individuals (of the same species) in each photo, taking into account that the species may be the 1st species detected in each photo, 2nd species detected in each photo, 3rd species detected in each photo, 4th species detected in each photo, or the 5th species detected in each photo in the case of multi-species photos.(Note: The species name is sensitive to case and spelling errors)

**Output:** Returns a new column in the specified camera dataframe labled by the specified species.
```{r}
speciestotal <- function(cameradf, species) {
  count1 <- ifelse(cameradf$Count1Species %in% species, cameradf$Count1Total, 0)
  count2 <- ifelse(cameradf$Count2Species %in% species, cameradf$Count2Total, 0)
  count3 <- ifelse(cameradf$Count3Species %in% species, cameradf$Count3Total, 0)
  count4 <- ifelse(cameradf$Count4Species %in% species, cameradf$Count4Total, 0)
  count5 <- ifelse(cameradf$Count5Species %in% species, cameradf$Count5Total, 0)
  total <- (count1+count2+count3+count4+count5)
  return(total)
}
```
***
### The "allspecies" Function

**Input:** A standard camera trap dataframe (i.e. camerdf). 

**What it Does:** This function uses the "speciestotal" function and applys it to all species in the dataframe.

**Output:** It returns a new dataframe that has 24 new columns, each column of which contains the total number of individuals (of that species) from each photo. 
```{r}
allspecies <- function(cameradf) {
  cameradf$ATV <- speciestotal(cameradf,  species = "ATV")
  cameradf$bear <- speciestotal(cameradf,  species = "Bear")
  cameradf$bobcat <- speciestotal(cameradf,  species = "Bobcat")
  cameradf$cottontail <- speciestotal(cameradf, species = "Cottontail")
  cameradf$cow <- speciestotal (cameradf, species = "Cow")
  cameradf$coyote <- speciestotal(cameradf, species = "Coyote")
  cameradf$dog <- speciestotal(cameradf, species = "Dog")
  cameradf$elk <- speciestotal (cameradf, species = "Elk")
  cameradf$greyfox <- speciestotal(cameradf, species = "Greyfox")
  cameradf$horse<- speciestotal (cameradf, species = "Horse")
  cameradf$horseback <- speciestotal (cameradf, species = "Horseback")
  cameradf$jackrabbit <- speciestotal (cameradf, species = "Jackrabbit")
  cameradf$deer <- speciestotal (cameradf, species = "Muledeer")
  cameradf$other <- speciestotal (cameradf, species = "Other")
  cameradf$human <- speciestotal (cameradf, species = "Person")
  cameradf$pronghorn <- speciestotal (cameradf, species = "Pronghorn")
  cameradf$raccoon <- speciestotal (cameradf, species = "Raccoon")
  cameradf$skunk <- speciestotal (cameradf, species = "Skunk")
  cameradf$truck <- speciestotal(cameradf, species = "Truck/SUV")
  cameradf$turkey <- speciestotal(cameradf, species = "Turkey")
  cameradf$ukncanine <- speciestotal(cameradf, species = "Unk Canine")
  cameradf$UTV <- speciestotal(cameradf, species = "UTV")
  cameradf$wolf <- speciestotal(cameradf, species = "Wolf")
  cameradf$na <- speciestotal(cameradf, species = "NA")
  return(cameradf)
}
```
***
### The "counts.df" Function

**Input:** A camera trap dataframe (i.e. camerdf) with 24 new columns generated by the "allspecies" function. 

**What it Does:** This function sums up the total number of individuals for horses, cows and elk (more species will be added later) and stores these sums in a new data frame (i.e. cameradf.counts).

**Output:** A new dataframe containing the cumulative sum of individuals for horses, cows, and elk.
```{r}
counts.df <- function(cameradf) {
  cameradf.counts <- data.frame(species = c("Horses", "Cattle", "Elk"), 
             freq = (c(sum(cameradf$horse), sum(cameradf$cow), sum(cameradf$elk)
                       )
                     )
             )
  }
```
***
### The "group.df" Function
**Input:** 

**What it Does:**

**Output:**
```{r}
group.df <- function (cameradf){
  
cameradf <- arrange(cameradf, DateTime)

lag_time_diff <- difftime(cameradf$DateTime, lag(cameradf$DateTime, default = cameradf$DateTime[1]), units = "mins")

cameradf$group <- cumsum(ifelse(lag_time_diff>10,1,0))
cameradf$group <- cameradf$group+1

return(cameradf)
}
```
***
### The "group.total"" Function

**Input:** 

**What it Does:** This function abstracts the group detections for each site.

**Output:**
```{r}
group.total <- function (cameradf){
cameradfhorses <- cameradf[cameradf$horse >0, ]
cameradfcows <- cameradf[cameradf$cow >0, ]
cameradfelk <- cameradf[cameradf$elk >0, ]

cameradfhorses <- arrange(cameradfhorses, DateTime)
lag_time_diff <- difftime(cameradfhorses$DateTime, lag(cameradfhorses$DateTime, default = cameradfhorses$DateTime[1]), units = "mins")
cameradfhorses$group <- cumsum(ifelse(lag_time_diff>10,1,0))
cameradfhorses$group <- cameradfhorses$group+1

cameradfcows <- arrange(cameradfcows, DateTime)
lag_time_diff <- difftime(cameradfcows$DateTime, lag(cameradfcows$DateTime, default = cameradfcows$DateTime[1]), units = "mins")
cameradfcows$group <- cumsum(ifelse(lag_time_diff>10,1,0))
cameradfcows$group <- cameradfcows$group+1

cameradfelk <- arrange(cameradfelk, DateTime)
lag_time_diff <- difftime(cameradfelk$DateTime, lag(cameradfelk$DateTime, default = cameradfelk$DateTime[1]), units = "mins")
cameradfelk$group <- cumsum(ifelse(lag_time_diff>10,1,0))
cameradfelk$group <- cameradfelk$group+1

horses <- if(length(tail(cameradfhorses$group, n = 1)) >0){
  tail(cameradfhorses$group, n = 1)
} else {
  0
}

cows <- if(length(tail(cameradfcows$group, n = 1)) >0){
  tail(cameradfcows$group, n = 1)
} else {
  0
}

elk <- if(length(tail(cameradfelk$group, n = 1)) >0){
  tail(cameradfelk$group, n = 1)
} else {
  0
}

return (cameradfGroups<- data.frame(species = c("horses", "cows", "elk"),
                         groups = (c(horses, cows, elk)
                                   )
                         )
        )
}
```
***
### The "sumbyhour" Function

**Input:** A camera trap dataframe that has split so each species is in a separate dataframe and has also been processed by the hour() function (from the lubridate package).

**What it Does:** This function takes the total number of individuals from each hourly interval (e.g., from 00:00:00 to 00:59:00) and puts each value into a temporary object (e.g., hour0). Each temporary object is then put into a data frame for organization.

**Output:** Returns a dataframe that contains the hourly totalnumber of individuals (for the entire season).
```{r}
sumbyhour<- function (cameradf, species){

cameradf$hour<- hour(cameradf$DateTime)

hour0 <- sum(ifelse (cameradf$hour == 0, cameradf[,species], 0))
hour1 <- sum(ifelse (cameradf$hour == 1, cameradf[,species], 0))
hour2 <- sum(ifelse (cameradf$hour == 2, cameradf[,species], 0))
hour3 <- sum(ifelse (cameradf$hour == 3, cameradf[,species], 0))
hour4 <- sum(ifelse (cameradf$hour == 4, cameradf[,species], 0))
hour5 <- sum(ifelse (cameradf$hour == 5, cameradf[,species], 0))
hour6 <- sum(ifelse (cameradf$hour == 6, cameradf[,species], 0))
hour7 <- sum(ifelse (cameradf$hour == 7, cameradf[,species], 0))
hour8 <- sum(ifelse (cameradf$hour == 8, cameradf[,species], 0))
hour9 <- sum(ifelse (cameradf$hour == 9, cameradf[,species], 0))
hour10 <- sum(ifelse (cameradf$hour == 10, cameradf[,species], 0))
hour11 <- sum(ifelse (cameradf$hour == 11, cameradf[,species], 0))
hour12 <- sum(ifelse (cameradf$hour == 12, cameradf[,species], 0))
hour13 <- sum(ifelse (cameradf$hour == 13, cameradf[,species], 0))
hour14 <- sum(ifelse (cameradf$hour == 14, cameradf[,species], 0))
hour15 <- sum(ifelse (cameradf$hour == 15, cameradf[,species], 0))
hour16 <- sum(ifelse (cameradf$hour == 16, cameradf[,species], 0))
hour17 <- sum(ifelse (cameradf$hour == 17, cameradf[,species], 0))
hour18 <- sum(ifelse (cameradf$hour == 18, cameradf[,species], 0))
hour19 <- sum(ifelse (cameradf$hour == 19, cameradf[,species], 0))
hour20 <- sum(ifelse (cameradf$hour == 20, cameradf[,species], 0))
hour21 <- sum(ifelse (cameradf$hour == 21, cameradf[,species], 0))
hour22 <- sum(ifelse (cameradf$hour == 22, cameradf[,species], 0))
hour23 <- sum(ifelse (cameradf$hour == 23, cameradf[,species], 0))
df <- data.frame(hour = c(0:23), freq = c(hour0, hour1, hour2, hour3, hour4, hour5, hour6, hour7, hour8, hour9, hour10, hour11, hour12, hour13, hour14, hour15, hour16, hour17, hour18, hour19, hour20, hour21, hour22, hour23))
return(df)
}
```
***
### The "group.duration" Function

**Input:** A camera trap data frame with only 1 species, such as BGW17horses. 

**What it Does:** This function calculates the amount of time each group spent at site (both in minutes and seconds). It does this by sequentially numbering each photo in a group. It then subracts the DateTime of the last photo from the DateTime of the first photo in each group sequence. It stores this value in a new object "total". If the total difference is less than 60 (seconds) such as when a single photo constitutes a group, we include an assumption that this single photo actually represents 60 seconds of site use. 

**Output:** Returns a numerical vector containing the number of minutes each group spent at that site.
```{r}
group.duration <- function(cameradfspecies) {
  if (length(cameradfspecies$group) < 1) { 
    cameradfspecies <- 0 # this is for dataframes that had 0 species detections (e.g., BGX18horses)
    cameradfspecies$group_sequence <- 0
    groupduration <- (as.numeric(cameradfspecies$group))
  } else {
    cameradfspecies$group_sequence <- 1
    for (i in 2:(length(cameradfspecies$group))) {  
      if (cameradfspecies[i,"group"] == cameradfspecies[(i-1),"group"]) {  
        cameradfspecies[i,"group_sequence"] <-cameradfspecies[i-1,"group_sequence"]+1  
      }
    }
    first_last <- cameradfspecies %>% arrange(group_sequence) %>% group_by(group) %>% slice(c(1,n()))
    first_last <- first_last %>% group_by(group) %>% mutate(Diff = DateTime - lag(DateTime)) 
    total <- first_last[!is.na(first_last$Diff),]
    total$Diff[total$Diff < 60] <- 60  # this assumes that if the time difference between the first and last photo is less than 0, then set it to 60 seconds. This value may be changed to 300 seconds (5 minutes) for sites that had 5 minute timelapse.
    groupduration <- (as.numeric(total$Diff))
#    groupduration <- remove_outliers(groupduration)
    duration.secs <- groupduration[!is.na(groupduration)]
    duration.mins <- (duration.secs/60) # ceiling() returns the smallest interger value that is not less than the input value (essentially it rounds up to the next highest interger value) 
  }
}
```
***
###

**Input:** 

**What it Does:**

**Output:**
```{r}
remove_outliers <- function(x, na.rm = TRUE, ...) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = na.rm, ...)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  y
}
```

